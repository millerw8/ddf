/**
 * Copyright (c) Codice Foundation
 * <p/>
 * This is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser
 * General Public License as published by the Free Software Foundation, either version 3 of the
 * License, or any later version.
 * <p/>
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
 * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details. A copy of the GNU Lesser General Public License
 * is distributed along with this program and can be found at
 * <http://www.gnu.org/licenses/lgpl.html>.
 */
package ddf.catalog.data.dynamic.registry;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import ddf.catalog.data.dynamic.impl.MetacardPropertyDescriptorImpl;

/**
 * MetacardAttribute provides a bridge between user-defined metacard attributes and the java
 * implementation of that attribute. It is used while reading metacard definitions to capture
 * the elements of a metacard attribute. Once the attribute elements have been read in, then
 * a dynamic metacard property can be generated by invoking the getMetacardPropertyDescriptor
 * method.
 */
public class MetacardAttribute {
    private static final Logger LOGGER = LoggerFactory.getLogger(MetacardPropertyDescriptorImpl.class);

    private String name;
    private String type;
    private boolean indexed;
    private boolean stored;
    private boolean tokenized;
    private boolean multiValued;

    private static final HashMap<String, Class<?>> TYPE_MAP = new HashMap<>();

    /*
     * These are the core types for all attributes. Domain-specific types will be a combination
     * of these core types and validation rules (e.g. XML is a string core type with xml
     * validators). The key of the map is what the metacard definition is expected to contain,
     * while the corresponding value is the Java class used to represent that in the attribute.
     */
    static {
        TYPE_MAP.put(String.class.getSimpleName(), String.class);
        TYPE_MAP.put(Date.class.getSimpleName(), Date.class);
        TYPE_MAP.put(Integer.class.getSimpleName(), Integer.class);
        TYPE_MAP.put(Long.class.getSimpleName(), long.class);
        TYPE_MAP.put(Float.class.getSimpleName(), float.class);
        TYPE_MAP.put(Double.class.getSimpleName(), double.class);
        TYPE_MAP.put(Boolean.class.getSimpleName(), boolean.class);
        TYPE_MAP.put("Binary", byte[].class);
    }


    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    public boolean isIndexed() {
        return indexed;
    }

    public void setIndexed(boolean indexed) {
        this.indexed = indexed;
    }

    public boolean isStored() {
        return stored;
    }

    public void setStored(boolean stored) {
        this.stored = stored;
    }

    public boolean isTokenized() {
        return tokenized;
    }

    public void setTokenized(boolean tokenized) {
        this.tokenized = tokenized;
    }

    public boolean isMultiValued() {
        return multiValued;
    }

    public void setMultiValued(boolean multiValued) {
        this.multiValued = multiValued;
    }

    /**
     * Returns a {@link MetacardPropertyDescriptorImpl} for the current attribute settings. This is
     * expected to be called after setting all the appropriate fields in the class (typically
     * through parsing an XML description of a metacard and its attributes).
     * @return a dynamic property descriptor representing the current attribute
     */
    public MetacardPropertyDescriptorImpl getMetacardPropertyDescriptor() {
        MetacardPropertyDescriptorImpl descriptor = null;
        if (multiValued) {
            LOGGER.debug("Creating multi-valued attribute with name {} and type {}", name, type);
            descriptor = new MetacardPropertyDescriptorImpl(name, ArrayList.class, TYPE_MAP.get(type), indexed, stored, tokenized);
        } else {
            LOGGER.debug("Creating single-valued attribute with name {} and type {}", name, type);
            descriptor = new MetacardPropertyDescriptorImpl(name, TYPE_MAP.get(type), indexed, stored, tokenized);
        }
        if (descriptor == null) {
            LOGGER.warn("Unable to create attribute with name {} and type {} - ignored.",
                    name,
                    type);
        }
        return descriptor;
    }
}
